<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>かんたんWebオシロスコープ（学校教材版）</title>
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'">
<style>
  :root{
    --ink:#0d2b66; --grid:#cfe2ff; --axis:#5b8bd9; --wave:#0066cc;
    --bg:#ffffff; --panel:#f5f9ff; --muted:#5f6b7a; --accent:#3b82f6;
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP","Yu Gothic UI","Meiryo",sans-serif}
  body{margin:0;background:var(--bg);color:var(--ink)}
  header{padding:10px 16px;border-bottom:1px solid #e6eefc;background:#fff;position:sticky;top:0;z-index:2}
  header h1{margin:0;font-size:18px}
  .wrap{max-width:1000px;margin:0 auto;padding:16px}
  .panel{background:var(--panel);border:1px solid #e6eefc;border-radius:14px;padding:12px;box-shadow:0 1px 0 rgba(13,43,102,.04)}
  .controls{display:grid;grid-template-columns:1fr;gap:12px}
  @media(min-width:820px){.controls{grid-template-columns: 1.1fr 1fr}}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .preset{display:grid;grid-template-columns:repeat(8,minmax(56px,1fr));gap:8px}
  button{border:0;border-radius:12px;padding:10px 12px;cursor:pointer;font-weight:600}
  button:focus{outline:2px solid #9cc4ff;outline-offset:2px}
  .note{height:44px}
  .note[data-n="ド"]{background:#fde68a}
  .note[data-n="レ"]{background:#fca5a5}
  .note[data-n="ミ"]{background:#fdba74}
  .note[data-n="ファ"]{background:#86efac}
  .note[data-n="ソ"]{background:#93c5fd}
  .note[data-n="ラ"]{background:#c4b5fd}
  .note[data-n="シ"]{background:#f0abfc}
  .note[data-n="ド↑"]{background:#a5f3fc}
  .tiny{font-size:12px;color:var(--muted)}
  .labeled{display:flex;align-items:center;gap:10px}
  .value-badge{min-width:62px;text-align:right;font-variant-numeric:tabular-nums}
  .value-badge strong{font-size:18px}
  .toggle{background:#fff;border:1px solid #d6e3ff}
  .toggle.on{background:#e0ecff}
  canvas{width:100%;height:300px;background:#fff;border:1px solid #e6eefc;border-radius:14px;display:block}
  .meter{min-width:160px;padding:8px 10px;border-radius:10px;background:#fff;border:1px solid #e6eefc}
  footer{padding:10px 16px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<header><h1>かんたんWebオシロスコープ（学校教材版）</h1></header>

<div class="wrap">
  <div class="controls panel">
    <!-- プリセット -->
    <div class="row" aria-label="プリセット音">
      <div class="preset" id="presetArea">
        <button class="note" data-n="ド"  data-f="349.228">ド</button>
        <button class="note" data-n="レ"  data-f="392.000">レ</button>
        <button class="note" data-n="ミ"  data-f="440.000">ミ</button>
        <button class="note" data-n="ファ" data-f="466.164">ファ</button>
        <button class="note" data-n="ソ"  data-f="523.251">ソ</button>
        <button class="note" data-n="ラ"  data-f="587.330">ラ</button>
        <button class="note" data-n="シ"  data-f="659.255">シ</button>
        <button class="note" data-n="ド↑" data-f="698.456">ド</button>
      </div>
    </div>

    <!-- 音量（発信器 出力％） -->
    <div class="row labeled" aria-label="音量">
      <label for="vol"><strong>音量</strong></label>
      <input id="vol" type="range" min="0" max="100" step="1" value="20" style="flex:1">
      <div class="value-badge"><strong id="volPct">20</strong>%</div>
      <span class="tiny">※発信器の出力値</span>
    </div>

    <!-- コントロール群：画面停止/音停止/マイク停止 -->
    <div class="row" style="gap:10px">
      <button id="freezeBtn" class="toggle" aria-pressed="false">画面停止</button>
      <button id="toneStopBtn" class="toggle">音の発信停止</button>
      <button id="micToggleBtn" class="toggle" aria-pressed="true">マイク停止</button>
      <span class="tiny">※画面停止で音も停止します</span>
    </div>
  </div>

  <!-- 表示部（dB表示 復活） -->
  <div class="panel" style="margin-top:12px">
    <div class="row" style="justify-content:space-between;align-items:flex-start;gap:12px">
      <div style="flex:1;min-width:260px">
        <canvas id="scope" width="1200" height="360" aria-label="マイク波形表示"></canvas>
      </div>
      <!-- ★追加：dB表示 -->
      <div class="meter" aria-live="polite">
        <div class="tiny">マイク音量（概算 dBFS）</div>
        <div style="font-variant-numeric:tabular-nums;font-size:24px" id="dbVal">--.- dB</div>
      </div>
    </div>
    <div class="tiny" style="margin-top:6px">
      表示はマイクで拾った波形／音量（dBFS）。周波数や時間目盛りは非表示。
    </div>
  </div>
</div>

<footer class="wrap">
  <div>© 教材用シンプル版 — 正弦波のみ／色分けボタン／音量％／画面停止＝音も停止／縦レンジ固定×8相当</div>
</footer>

<script>
(() => {
  // ====== Audio 基本 ======
  const AC = window.AudioContext || window.webkitAudioContext;
  const audio = new AC({latencyHint:'interactive'});

  let osc = null;
  const tonePreGain = audio.createGain(); // （補正用だが今回は常に1.0）
  tonePreGain.gain.value = 1.0;

  const outGain = audio.createGain();     // ユーザー音量（％）
  outGain.gain.value = 0.20;              // 初期20%
  tonePreGain.connect(outGain).connect(audio.destination);

  // ====== マイク ======
  const anaMic = audio.createAnalyser();
  anaMic.fftSize = 2048;
  anaMic.smoothingTimeConstant = 0.10;
  const timeMic = new Uint8Array(anaMic.fftSize);

  let micReady = false;
  let micStreamNode = null;
  let micStream = null;

  async function startMic(){
    if(micReady) return;
    try{
      micStream = await navigator.mediaDevices.getUserMedia({
        audio:{
          echoCancellation:false, noiseSuppression:false, autoGainControl:false,
          channelCount:1, sampleRate: audio.sampleRate
        }
      });
      micStreamNode = audio.createMediaStreamSource(micStream);
      micStreamNode.connect(anaMic);
      micReady = true;
      micToggleBtn.classList.add('on');
      micToggleBtn.setAttribute('aria-pressed','true');
      micToggleBtn.textContent = 'マイク停止';
    }catch(e){
      alert('マイクの許可が必要です。ブラウザの許可設定をご確認ください。');
    }
  }
  function stopMic(){
    try{ micStreamNode && micStreamNode.disconnect(); }catch{}
    if(micStream){ micStream.getTracks().forEach(t=>t.stop()); }
    micStreamNode = null; micStream = null; micReady = false;
    micToggleBtn.classList.remove('on');
    micToggleBtn.setAttribute('aria-pressed','false');
    micToggleBtn.textContent = 'マイク開始';
  }

  // ====== UI 要素 ======
  const vol = document.getElementById('vol');
  const volPct = document.getElementById('volPct');
  const scope = document.getElementById('scope');
  const ctx = scope.getContext('2d');
  const freezeBtn = document.getElementById('freezeBtn');
  const toneStopBtn = document.getElementById('toneStopBtn');
  const micToggleBtn = document.getElementById('micToggleBtn');
  const dbVal = document.getElementById('dbVal'); // ★追加

  // ====== 縦レンジ：固定（×8 相当） ======
  const visGain = 8;

  function setVolumeFromSlider(){
    const pct = Number(vol.value)/100;          // 0-1
    outGain.gain.setValueAtTime(pct, audio.currentTime);
    volPct.textContent = Math.round(Number(vol.value));
  }
  vol.addEventListener('input', setVolumeFromSlider);

  // ====== 補正は常にオフ（1.0倍） ======
  let currentNoteName = null;
  function applyToneComp(noteName){
    currentNoteName = noteName || currentNoteName;
    tonePreGain.gain.setValueAtTime(1.0, audio.currentTime); // 補正オフ
  }

  function startOsc(freq, noteName){
    stopOsc();
    osc = audio.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audio.currentTime);
    osc.connect(tonePreGain);
    applyToneComp(noteName);
    osc.start();
  }
  function stopOsc(){
    if(osc){
      try{ osc.stop(); }catch{}
      try{ osc.disconnect(); }catch{}
      osc = null;
    }
  }

  // プリセット押下で再生＆マイク起動
  document.getElementById('presetArea').addEventListener('click', async (e)=>{
    const btn = e.target.closest('.note'); if(!btn) return;
    if(audio.state !== 'running'){ try{ await audio.resume(); }catch{} }
    await startMic();
    const f = Number(btn.dataset.f);
    const name = btn.dataset.n;
    startOsc(f, name);
  });

  // ====== 画面停止（音も停止） ======
  let freeze = false;
  freezeBtn.addEventListener('click', ()=>{
    freeze = !freeze;
    freezeBtn.classList.toggle('on', freeze);
    freezeBtn.setAttribute('aria-pressed', String(freeze));
    freezeBtn.textContent = freeze ? '画面停止（停止中：音も停止）' : '画面停止';
    if(freeze){ stopOsc(); } else { drawOnce(true); }
  });

  // 個別ボタン：音の発信停止／マイク停止・開始
  toneStopBtn.addEventListener('click', ()=> stopOsc());
  micToggleBtn.addEventListener('click', async ()=>{
    const on = micToggleBtn.classList.contains('on');
    if(on){ stopMic(); } else { await startMic(); }
  });

  // ====== 描画 ======
  function drawGrid(){
    const W = scope.width, H = scope.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
    ctx.lineWidth = 1; ctx.beginPath();
    const gy = 6, gx = 12;
    for(let i=1;i<gy;i++){ const y = Math.round(H*i/gy)+0.5; ctx.moveTo(0,y); ctx.lineTo(W,y); }
    for(let i=1;i<gx;i++){ const x = Math.round(W*i/gx)+0.5; ctx.moveTo(x,0); ctx.lineTo(x,H); }
    ctx.stroke();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis');
    ctx.beginPath(); ctx.moveTo(0,H/2+0.5); ctx.lineTo(W,H/2+0.5); ctx.stroke();
  }

  function drawWave(){
    const W = scope.width, H = scope.height;
    if(!micReady){
      ctx.fillStyle = '#999';
      ctx.fillText('マイク未許可：プリセットを押すか、マイク開始を押してください', 20, 28);
      return;
    }
    const buf = timeMic;
    anaMic.getByteTimeDomainData(buf);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wave');
    ctx.lineWidth = 2; ctx.beginPath();
    const step = Math.ceil(buf.length / W);
    for(let x=0,i=0; x<W; x++, i+=step){
      const v = (buf[i]-128)/128;                 // -1..+1
      const y = H/2 - v * (H*0.45*visGain);       // 固定×8相当
      const yy = Math.max(1, Math.min(H-1, y));
      if(x===0) ctx.moveTo(0,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();
  }

  // ★追加：dBFS 計算と表示（RMS→dBFS）
  let dbSmooth = null; // 簡易EMAで読み取りを安定化
  function calcDbFS(){
    if(!micReady){ dbVal.textContent='--.- dB'; return; }
    const buf = new Float32Array(anaMic.fftSize);
    anaMic.getFloatTimeDomainData(buf);
    let sum=0;
    for(let i=0;i<buf.length;i++){ const v=buf[i]; sum += v*v; }
    const rms = Math.sqrt(sum / buf.length) || 0;
    let db = 20 * Math.log10(rms);
    if(!isFinite(db)) db = -90;
    db = Math.max(db, -90); // 表示下限
    // 簡易スムージング（α=0.2）
    dbSmooth = (dbSmooth==null) ? db : (dbSmooth*0.8 + db*0.2);
    dbVal.textContent = dbSmooth.toFixed(1) + ' dB';
  }

  function drawOnce(force=false){
    if(freeze && !force) return;
    drawGrid(); drawWave(); calcDbFS(); // ★dB更新
  }
  (function loop(){ drawOnce(); requestAnimationFrame(loop); })();

  // ====== 初期化 ======
  setVolumeFromSlider(); // 音量％
})();
</script>
</body>
</html>
